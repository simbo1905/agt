# AGT Architecture Design (2026-01-04)

This document captures the target architectural state of AGT as of January 4, 2026.

## Terminology

| Term | World | Meaning |
|------|-------|---------|
| **Session** | Disk | An agent run with a unique ID, folder on disk, conversation history |
| **Session folder** | Disk | The folder on disk where the session lives (`sessions/<id>/`) |
| **Sandbox** | Disk | The folder where the agent runs, jailed into which is a git worktree checkout (`sessions/<id>/sandbox/`) |
| **Shadow branch** | Git | The branch where autocommits are stored (`agtsessions/<id>`) |
| **User branch** | Git | The branch standard commits of the user codebase are made |
| **Shadow commit** | Git | An autocommit on the shadow branch with two parents discussed below |
| **Shadow tree** | Git | The tree object in a shadow commit |
| **Shadow root** | Git | The root of the shadow tree (which is the session folder) |
| **Profile** | Config | Tool-specific folder requirements (opencode, cursor, claude-code, etc.) |

Commits made by the tooling/agent in the sandbox folder `sessions/<id>/sandbox/` are logically at the root of the repo and only see files inside the jail. These are committed to standard user branches. Only these branches may be exported back to remote repos. 

Commits made using autocommit have a logical file system that is one level higher than user commits `sessions/<id>/` and overlap. There is no `.gitignore`, no `git add` and no `git index`. Everything is automatically added and committed to the shadow branch based on file modification time. The tree overlaps with the user commits, which are required to snapshot files that are marked `.gitignore`. The git index file of what the agent has added is also added into the shadow commit as a file `_/index`. 

The design is intended to allow full-time travel when the agent is configured to log its actions to a jailed-mounted file location in the `sessions/<id>/` folder. Any or all of the `sessions/<id>/` can be deleted to save space. Yet a command can be run to recreate the `sessions/<id>/` as at a specific shadow commit. This will restore 

## CLI Commands

| Command | Purpose |
|---------|---------|
| `agt clone <url>` | Clone remote repo, create bare repo with main worktree |
| `agt session new [--id <id>]` | Create new session for a fresh ticket |
| `agt session autocommit` | Create shadow commit capturing session state |
| `agt session export` | Push user branch to remote (e.g. `origin`) |
| `agt session remove <id>` | Remove a session and its shadow branch |
| `agt session restore` | Checkout the `sessions/<id>/` to a prior shadow state |
| `agt session fork <from-id>` | Fork existing session (advanced, for parallel work)  |


Shadow branches (`agtsessions/*`) are **never** pushed to origin. Only user branches are exported.

## 1. High-Level Concept

AGT (Agent Git Tool) provides a time-travelling, immutable filesystem for AI agents. Agents work in parallel on the same codebase without interfering with each other or the user, while everything is **everything** (code, config, runtime state, session messages) in the git graph. 

Key design points:
- **Infrastructure**: Primary target is Linux (VM or VPS) with chroot jails.
- **Isolation**: Agents are jailed in their sandbox folder.
- **State Capture**: Autocommit captures the entire session folder as the shadow tree.
- **Profiles**: Different tools (opencode, cursor, etc.) have different folder requirements; profiles define what gets mounted into the jail.

The idea of a profile is to ensure that the correct agent config and agent state folders are mounted into the sandbox jail. 

## 2. Session Layout

A session is a folder on disk. The shadow tree mirrors this folder exactly.

### Disk Layout (Session Folder)

The following sketches a possible layout for opencode

```
sessions/<id>/                    # Session folder
└── _/                            # AGT system folder
    └── index                     # Git index blob (captured state)
├── sandbox/                      # Agent runs here (jailed)
│   ├── src/
│   ├── Cargo.toml
│   └── .git                      # Points to bare repo
├── xdg/                          # XDG_DATA_HOME (agent "~" state)
│   └── opencode/
│       └── storage/
├── config/                       # XDG_CONFIG_HOME (tool config)
│   └── opencode/
│       └── opencode.json
```

The aim is to ensure that the agent tool (i.e. `opencode`) has its config and state all within the `sessions/<id>/` so that the autocommit snapshots everything. The `_/index` file snapshots what has been added but not committed in the `sandbox` worktree. 

### Git Layout (Shadow Tree)

The shadow tree is just the session folder as a git tree:

```
(shadow root)                     # = sessions/<id>/ on disk
├── sandbox/
│   ├── src/
│   └── Cargo.toml
├── xdg/
│   └── opencode/...
├── config/
│   └── opencode/...
└── _/
    └── index                     # Git index at time of autocommit
```

Different tools require different folders. The profile defines which folders exist in the session folder and which are mounted in jail. Autocommit automatically captures everything in the session folder. Different profiles may be created to set up the sandbox to work with different agentic tools. 

## 3. Shadow Branch Topology

User branches (`main`, `develop`, `feat/xyz`) remain **completely clean**. Standard git operations work normally inside the sandbox against the user branch. The shadow commit backsup the git index of the working tree. If an agent is set to "autocommit", there will be matching commits between the two branches. If the agent is not set to autocommit, then the shadow commits make a complete backup, including `git add`/`git rm` that have not yet been committed. 

Shadow commits capture the full session state.

```
User Branch (clean)                Shadow Branch (session snapshots)
==================                 =================================

  main                              agtsessions/agent-001
    │                                        │
    ▼                                        │
  [A]─────────────────────────────────►[Fork]◄── parent2 = main HEAD
    │                                        │
    ▼                                        ▼
  [B] ← user commits normally         [SC1]◄─┬── parent1 = Fork
    │   (git add/commit in sandbox)          └── parent2 = main HEAD
    │                                        │
    ▼                                        ▼
  [C]                                  [SC2]◄─┬── parent1 = SC1
    │                                        └── parent2 = main HEAD
    ▼
  [D] ← user can keep working          ... shadow commits continue
```

**Key Points**:
1. **No merge** - Shadow commits reference the user branch as parent2, but don't merge into it. 
2. **Two parents** - Every shadow commit has: parent1 = previous shadow commit, parent2 = user branch tip.
3. **Git Index backup** - Every shadow commit exports the sandbox git index file to back it up in a `_` folder in the shadow commit. 
4. **Different tree roots**:
   - User branch tree: rooted at sandbox contents (the code)
   - Shadow tree: rooted at session folder (sandbox + xdg + config + _/)

The autocommit does not use a `.gitignore` file and does not need a `git add`; instead, it can use file creation and modification times to find all new and modified files. To find deleted files, it simply scans the shadow branch tree and compares it to the files on disk to detect files that were moved or removed. 

**Recovery Process**:
To restore session state at shadow commit `[SC2]`:
1. The sandbox jail is recreated.
2. Inside sandbox, checkout user branch (parent2 of `[SC2]`).
3. At the top-level checkout, the session branch (parent1 of `[SC2]`).
4. Restore `_/index` as the git index.
5. Agent sees: clean user code + captured environment + index state.

Note that the shadow commit will have backed up things like `node_modules` that were in the `.gitignore` of the user branch. When the shadow branch is checked out, these files will be restored. 

Note that the profile that jail mounts the agent config, message files and session state, should be set up to ensure that the shadow commit puts the agent into the exact historic state.  

## 4. Profiles

A profile defines what folders a tool needs in its jail. Examples:

| Tool | Folders Required |
|------|------------------|
| opencode | `xdg/`, `config/` |
| vibe | TBD |
| gemini-cli | TBD |

When `agt session new` creates a session, it creates folders based on the profile. This will involve invoking an `agt-sandbox` script to set up the correct chroot jail commands. Those will be on a per-agent basis to be bind-mounted to the locations the tool expects (e.g., `~/.local/share/`, `~/.config/`).

Autocommit doesn't care about profiles - it just captures everything in the session folder.

## 5. Component Architecture

```mermaid
flowchart TB
    subgraph HostVM[1. Host / VM]
        A1["2. agt (Host CLI)"]
        A2["3. Host Git Binary"]
        A4["4. agent sandbox (per profile helper)"]
    end

    subgraph SessionFolder[6. Session Folder]
        B1["7. agt-sandbox directory (sessions/id/sandbox/)"]
        B2["8. Tool State (xdg/, config/)"]
    end

    subgraph GitWorld[9. Git World]
        C1["10. Bare Repo (name.git)"]
        C2["11. User Branches (refs/heads/main, feat/...)"]
        C3["12. Shadow Branches (agtsessions/id)"]
    end

    A1 -- "clone, session, autocommit" --> C1
    A1 -- "autocommit scans" --> B1
    A1 -- "autocommit scans" --> B2
    A1 -- "creates shadow commits" --> C3
    C3 --> C1

    A2 -- "updates user branches" --> C2
    C2 --> C1

    A1 -- "shells out" --> A2
    A1 -- "uses for sandbox setup" --> A4
    A4 -- "configures sandbox directory" --> B1
    A4 -- "prepares tool state/config" --> B2
```

## 6. Key Flows

The sequence diagrams in this section use descriptive participant names that
match the components from the component diagram above. `autonumber` is enabled
so each message is numbered automatically.

### `agt clone <url>`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant host_git as "Host git binary"
    participant bare_repo as "Bare repo"
    participant user_branches as "User branches"

    agt_cli->>host_git: Request to clone remote repository using host git binary
    host_git->>bare_repo: Create bare repository and initial user branch
    agt_cli->>bare_repo: Write AGT metadata into the bare repository
    agt_cli->>user_branches: Prepare main worktree tracking the user branch
```

Resulting layout (conceptual):

```
org/repo/
├── .bare/              # Bare repository (git database)
├── .git                # Text file pointing to .bare
├── main/               # Primary worktree (main branch)
└── sessions/           # Session folders live here
```

### `agt session new [--id <id>]`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant sandbox_helper as "Sandbox helper"
    participant sandbox_dir as "Sandbox directory"
    participant tool_state as "Tool state/config"
    participant bare_repo as "Bare repo"
    participant user_branches as "User branches"
    participant shadow_branches as "Shadow branches"

    agt_cli->>bare_repo: Resolve starting commit and record session metadata
    agt_cli->>user_branches: Associate the session with a user branch reference
    agt_cli->>shadow_branches: Create a shadow branch for the new session
    agt_cli->>sandbox_helper: Invoke sandbox helper for this profile
    sandbox_helper->>sandbox_dir: Configure the sandbox directory worktree
    sandbox_helper->>tool_state: Prepare tool state and config folders
```

### `agt session export`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant host_git as "Host git binary"
    participant sandbox_dir as "Sandbox directory"
    participant user_branches as "User branches"

    agt_cli->>sandbox_dir: Locate the sandbox directory for the target session
    agt_cli->>host_git: Request push of current branch from sandbox worktree
    host_git->>user_branches: Update the corresponding user branch on the remote
```

Shadow branches are not exported; only user branches are pushed.

### `agt session remove <id>`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant host_git as "Host git binary"
    participant sandbox_dir as "Sandbox directory"
    participant bare_repo as "Bare repo"
    participant shadow_branches as "Shadow branches"

    agt_cli->>sandbox_dir: Remove the session sandbox directory and folder tree
    agt_cli->>bare_repo: Remove session metadata from the bare repository
    agt_cli->>host_git: Request deletion of the session shadow branch
    host_git->>shadow_branches: Delete the shadow branch reference
```

### `agt session fork <from-id> [--id <new-id>]`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant sandbox_helper as "Sandbox helper"
    participant sandbox_dir as "Sandbox directory"
    participant tool_state as "Tool state/config"
    participant bare_repo as "Bare repo"
    participant user_branches as "User branches"
    participant shadow_branches as "Shadow branches"

    agt_cli->>bare_repo: Read metadata of the source session
    agt_cli->>user_branches: Reuse the source session user branch
    agt_cli->>shadow_branches: Create a new shadow branch from source state
    agt_cli->>sandbox_helper: Invoke sandbox helper to set up forked session
    sandbox_helper->>sandbox_dir: Create the forked sandbox directory worktree
    sandbox_helper->>tool_state: Prepare tool state and config for the fork
```

### `agt autocommit`

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant sandbox_dir as "Sandbox directory"
    participant tool_state as "Tool state/config"
    participant bare_repo as "Bare repo"
    participant user_branches as "User branches"
    participant shadow_branches as "Shadow branches"

    agt_cli->>bare_repo: Read previous autocommit metadata and timestamps
    agt_cli->>sandbox_dir: Scan sandbox directory for changed files
    agt_cli->>tool_state: Scan tool state and config directories
    agt_cli->>user_branches: Resolve current user branch tip
    agt_cli->>shadow_branches: Write a new shadow commit for the session
```

### Recovery (future `agt session restore`)

```mermaid
sequenceDiagram
    autonumber
    participant agt_cli as "agt CLI"
    participant sandbox_helper as "Sandbox helper"
    participant sandbox_dir as "Sandbox directory"
    participant tool_state as "Tool state/config"
    participant bare_repo as "Bare repo"
    participant user_branches as "User branches"
    participant shadow_branches as "Shadow branches"

    agt_cli->>bare_repo: Select a shadow commit for the target session
    agt_cli->>shadow_branches: Read the shadow tree snapshot for that commit
    agt_cli->>sandbox_helper: Invoke sandbox helper to reconstruct the session
    sandbox_helper->>sandbox_dir: Restore sandbox directory contents
    sandbox_helper->>tool_state: Restore tool state and config folders
    agt_cli->>user_branches: Reset sandbox worktree to the user branch commit
```

## 7. Testing Infrastructure

```mermaid
flowchart LR
    Dev[Developer Machine]
    
    subgraph "Local Tests"
        Unit[Rust Unit Tests]
        Integ[Integration Tests]
    end
    
    subgraph "Lima VM"
        JailScripts[Toybox Jail Scripts]
        Suite12[Suite 12: Isolation]
        AgentRun[Agent Execution]
    end
    
    Dev -- "cargo test" --> Unit
    Dev -- "cargo test" --> Integ
    Dev -- "just run-lima" --> Suite12
```

- **Working VM**: `agt_agent_sandbox` (can be reset)
- **Backup VM**: `agt_sandbox_backup` (never delete)
- **Toybox**: Submodule providing chroot jail tools
